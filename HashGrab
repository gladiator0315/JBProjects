--// Check if already in env

if networkKeys and network then 
    return networkKeys, network
end

--// Wait for game load

if not game:IsLoaded() then
    game.Loaded:Wait()
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = game:GetService("Players").LocalPlayer

if not player.Character then
    player.CharacterAdded:Wait()
end

local setEvent = require(ReplicatedStorage:WaitForChild("Module").AlexChassis).SetEvent
local network = getupvalue(setEvent, 1)

while not network and task.wait() do
    network = getupvalue(setEvent, 1)
end

--// Variables

local startTime = os.clock()

local CollectionService = game:GetService("CollectionService")

local keysList = getupvalue(getupvalue(network.FireServer, 1), 3)

local gameFolder = ReplicatedStorage.Game
local robloxEnvironment = getrenv()

local teamChooseUI = require(ReplicatedStorage.TeamSelect.TeamChooseUI) -- module used in multiple keys
local defaultActions = require(gameFolder.DefaultActions) -- module used in multiple keys
local itemSystem = require(gameFolder.ItemSystem.ItemSystem) -- module used in multiple keys

local networkKeys = {}
local keyFunctions = {}
local blacklistedConstants = {}
local keyCache = {}
local backupKeys = { -- could do getinfo numparams but this is faster
    Arrest = true,
    Breakout = true,
    Eject = true
}

local exceptionKeys = { -- keys to use alternative method (deemed to be more efficient for these cases)
    PlaySound = function(checkFunction)
        return getconstants(checkFunction)[1] == "Source"
    end,
    CameraUpdate = function(checkFunction)
        return getconstants(checkFunction)[1] == "MakeSpring"
    end
}

for index, value in getrenv() do -- soooo bad
    if index ~= "_G" and index ~= "shared" and typeof(value) == "table" then
        for name in value do
            table.insert(blacklistedConstants, name)
        end
    end

    table.insert(blacklistedConstants, index)
end

--// Functions

local function fetchKey(callerFunction, keyIndex, multiSearch)
    keyIndex = keyIndex or 1
    
    if keyCache[callerFunction] then
        local correctKey = keyCache[callerFunction][keyIndex]

        return correctKey and correctKey[1] or "Failed to fetch key"
    end
    
    local constants = getconstants(callerFunction)
    local originalConstants = table.clone(constants)
    
    local prefixIndexes = {}
    local foundKeys = {}
    local constantCharacters = {}
    
    for index, constant in constants do
        if keysList[constant] then -- if the constants already contain the raw key
            table.insert(foundKeys, { constant, 0 })
            
            constants[index] = nil
        elseif typeof(constant) ~= "string" or constant == "" or constant:match("[%u%W]") or table.find(blacklistedConstants, constant) then
            constants[index] = nil -- remove constants that are 100% not the ones we need to make it a bit faster
        else
            for character in constant:gmatch("(%w)") do
                table.insert(constantCharacters, character)
            end
        end
    end
    
    for key, remote in keysList do
        local prefixPassed, prefixIndex = false
        local keyLength = #key
        
        for index, constant in constants do
            local constantLength = #constant

            if not prefixPassed and key:sub(1, constantLength) == constant then -- check if the key starts with one of the constants
                prefixPassed, prefixIndex = constant, index
            elseif prefixPassed and key:sub(keyLength - (constantLength - 1), keyLength) == constant then -- check if the key ends with one of the constants
                local currentConstantCharacters = table.clone(constantCharacters)
                local charactersValid = true

                for character in key:gmatch("(%w)") do -- make sure every character in the key shows up
                    if not table.find(currentConstantCharacters, character) then
                        charactersValid = false
                        
                        break
                    end
                    
                    table.remove(currentConstantCharacters, table.find(currentConstantCharacters, character))
                end
                
                if charactersValid then
                    table.insert(prefixIndexes, prefixIndex)
                    table.insert(foundKeys, { key, index })
                end

                break
            end
        end
    end
    
    -- cleanse invalid keys
    for index, keyInfo in foundKeys do
        if table.find(prefixIndexes, keyInfo[2]) then -- invalid keys will have a suffix of a prefix used in another key
            table.remove(foundKeys, index)
        end
    end
    
    keyCache[callerFunction] = foundKeys

    if multiSearch then
        return foundKeys, originalConstants, constants, prefixIndexes
    end

    local correctKey = foundKeys[keyIndex]

    return correctKey and correctKey[1] or "Failed to fetch key"
end

local function errorHandle(callback)
    local success, returnValue = pcall(callback)

    if not success then
        return warn("Jailbreak Key Fetcher Error: " .. returnValue)
    end

    return returnValue
end

local function errorHandleMultiSearch(callerFunction, keyNames)
    local success, foundKeys, orginalConstants, modifiedConstants, prefixIndexes = pcall(function()
        return fetchKey(callerFunction, nil, true)
    end)

    if not success then
        for _, keyName in keyNames do
            networkKeys[keyName] = ("Failed to fetch key ( %s )"):format(foundKeys)
        end

        return false
    end

    return foundKeys, orginalConstants, modifiedConstants, prefixIndexes
end

--// Fetch functions for keys

do -- redeemcode
    keyFunctions.RedeemCode = function()
        return getproto(require(gameFolder.Codes).Init, 8)
    end
end

do -- kick
    keyFunctions.Kick = function()
        local doorRemovedFunction = getconnections(CollectionService:GetInstanceRemovedSignal("Door"))[1].Function

        return getupvalue(getupvalue(getupvalue(getupvalue(doorRemovedFunction, 2), 2).Run, 1), 1)[4].c
    end
end

do -- damage
    keyFunctions.Damage = function()
        local militaryAddedFunction = require(gameFolder.MilitaryTurret.MilitaryTurretBinder)._classAddedSignal._handlerListHead._fn

        return getproto(militaryAddedFunction, 1)
    end
end

do -- jointeam
    keyFunctions.JoinTeam = function()
        for _, p in ipairs(getprotos(teamChooseUI.Show)) do
            if type(p) == "function" then
                local con = getconstants(p)
                if table.find(con, "st") and table.find(con, "r") then
                    return p 
                end
            end
        end
    end
end

do -- switchteam
    keyFunctions.SwitchTeam = function()
        local SideUI = require(gameFolder.SidebarUI)
        for _, p in ipairs(getprotos(SideUI.Init)) do
            if type(p) == "function" then
                for _, p1 in ipairs(getprotos(p)) do
                    if type(p1) == "function" then
                        for _, target in ipairs(getprotos(p1)) do
                            if type(target) == "function" then
                                local con = getconstants(target)
                                for _, v in ipairs(con) do
                                    if type(v) == "string" and #v >= 8 and v ~= "Parent" then
                                        return target
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

do -- exitcar
    keyFunctions.ExitCar = function()
        return getupvalue(teamChooseUI.Init, 3)
    end
end

do -- taze
    keyFunctions.Taze = function()
        return require(gameFolder.Item.Taser).Tase
    end
end
    
do -- droprope
    keyFunctions.DropRope = function()
        return getproto(require(gameFolder.Vehicle.Heli), 5)
    end
end

do -- punch
    keyFunctions.Punch = function()
        return getupvalue(defaultActions.punchButton.onPressed, 1).attemptPunch
    end
end

do -- arrest / pickpocket / breakout
    local characterInteractFunction = errorHandle(function()
        return getupvalue(getupvalue(require(ReplicatedStorage.App.CharacterBinder)._classAddedSignal._handlerListHead._fn, 1), 2)
    end)

    keyFunctions.Arrest = function(backup)
        if backup then
            return getupvalue(getupvalue(characterInteractFunction, 1), 7)
        else
            return getupvalue(characterInteractFunction, 1)
        end
    end

    keyFunctions.Pickpocket = function()
        return getupvalue(characterInteractFunction, 4)
    end
    
    keyFunctions.Breakout = function(backup)
        return characterInteractFunction
    end
end

do -- broadcastinputbegan / broadcastinputended
    keyFunctions.BroadcastInputBegan = function()
        return getproto(itemSystem._equip, 5)
    end

    keyFunctions.BroadcastInputEnded = function()
        return getproto(itemSystem._equip, 6)
    end
end

do -- eject / hijack / entercar
    local seatInteractFunction = errorHandle(function()
        return getupvalue(getconnections(CollectionService:GetInstanceAddedSignal("VehicleSeat"))[1].Function, 1)
    end)
    
    keyFunctions.Hijack = function()
        return getupvalue(seatInteractFunction, 1)
    end

    keyFunctions.Eject = function(backup)
        if backup then
            return getupvalue(seatInteractFunction, 2)
        else
            return seatInteractFunction
        end
    end

    keyFunctions.EnterCar = function()
        return getupvalue(seatInteractFunction, 3)
    end
end

do -- robstart / robend
    local robFunction = errorHandle(function()
        return getupvalue(getconnections(CollectionService:GetInstanceAddedSignal("SmallStore"))[1].Function, 1)
    end)

    local foundKeys, orginalConstants, modifiedConstants, prefixIndexes = errorHandleMultiSearch(robFunction, { "RobEnd", "RobStart" })

    if foundKeys then
        for index = 1, 2 do
            local key = foundKeys[index] and foundKeys[index][1] or "Failed to fetch key"
            local originalPrefixIndex = table.find(orginalConstants, modifiedConstants[prefixIndexes[index]])
            local previousConstant = originalPrefixIndex and orginalConstants[originalPrefixIndex - 1]
    
            networkKeys[previousConstant == "FireServer" and "RobEnd" or "RobStart"] = key
        end
    end
end

do -- opendoor
    -- this may not work on all exploits, your exploit must support the gc argument for getproto
    -- you can replace it with a gc search for a function with the constant "SequenceRequireState" if your exploit doesnt support this

    keyFunctions.OpenDoor = function()
        local doorAddedFunction = getconnections(CollectionService:GetInstanceAddedSignal("Door"))[1].Function

        return getupvalue(getproto(getupvalue(doorAddedFunction, 2), 1, true)[1], 7)
    end
end

do -- falldamage
    keyFunctions.FallDamage = function()
        return getupvalue(defaultActions.onJumpPressed._handlerListHead._next._fn, 2)
    end
end

do -- Dynamic GunShop key detection (semantic order: Unequip → Equip → Buy)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local gunShopUI = require(ReplicatedStorage:WaitForChild("Game").GunShop.GunShopUI)
    local displayListFunc = gunShopUI.displayList
    if not displayListFunc then return end

    local function safe(f, ...)
        local ok, res = pcall(f, ...)
        return ok and res or nil
    end

    local bestProto, candidateKeys
    for i = 1, safe(getnproto, displayListFunc) or 20 do
        local proto = safe(getproto, displayListFunc, i, false)
        if not proto then continue end

        local consts = safe(getconstants, proto) or {}
        local joined = table.concat(consts, " "):lower()

        if joined:find("doesplayerown") or joined:find("getequipped") then
            local found = {fetchKey(proto, nil, true)}
            if found and found[1] and #found[1] == 3 then
                bestProto = proto
                candidateKeys = found[1]
                break
            end
        end
    end

    if not candidateKeys then return end

    ----------------------------------------------------------------
    -- Detect which branch corresponds to which logical action
    ----------------------------------------------------------------
    local mapping = { Unequip = nil, Equip = nil, Buy = nil }

    local function scan(func)
        if type(func) ~= "function" then return end

        local consts = safe(getconstants, func) or {}
        local text = table.concat(consts, " "):lower()

        -- identify each condition contextually
        if text:find("getequipped") then
            mapping.Unequip = mapping.Unequip or func
        elseif text:find("doesplayerown") then
            mapping.Equip = mapping.Equip or func
        elseif text:find("fireserver") and not (text:find("getequipped") or text:find("doesplayerown")) then
            mapping.Buy = mapping.Buy or func
        end

        local count = safe(getnproto, func) or 0
        for i = 1, count do
            scan(safe(getproto, func, i))
        end
    end
    scan(bestProto)

    ----------------------------------------------------------------
    -- Assign keys explicitly following the real in-game logic
    ----------------------------------------------------------------
    local keyA = candidateKeys[1] and candidateKeys[1][1] or "Unknown"
    local keyB = candidateKeys[2] and candidateKeys[2][1] or "Unknown"
    local keyC = candidateKeys[3] and candidateKeys[3][1] or "Unknown"

    -- figure out which constant appeared near which check
    local function findClosest(func)
        local consts = safe(getconstants, func) or {}
        for _, k in ipairs(candidateKeys) do
            local key = k[1]
            for _, c in ipairs(consts) do
                if type(c) == "string" and key:sub(1, 3) == c:sub(1, 3) then
                    return key
                end
            end
        end
    end

    local unequipKey = mapping.Unequip and findClosest(mapping.Unequip) or keyA
    local equipKey   = mapping.Equip   and findClosest(mapping.Equip)   or keyB
    local buyKey     = mapping.Buy     and findClosest(mapping.Buy)     or keyC

    -- Final assignment (hard enforce correct logic order)
    networkKeys.UnequipGun = unequipKey
    networkKeys.EquipGun   = equipKey
    networkKeys.BuyGun     = buyKey
end

do -- ragdoll
    keyFunctions.Ragdoll = function()
        return require(gameFolder.Falling).StartRagdolling
    end
end

do -- exception keys
    local exceptionKeysFound, exceptionKeyCount = 0, 0
    
    for _ in exceptionKeys do
        exceptionKeyCount += 1
    end
    
    local success, errorMessage = pcall(function()
        for key, clientFunction in getupvalue(teamChooseUI.Init, 2) do 
            if typeof(clientFunction) == "function" then
                for keyName, keyCheck in exceptionKeys do
                    if keyCheck(clientFunction) then
                        exceptionKeysFound += 1
                        networkKeys[keyName] = key

                        break
                    end
                end
                
                if exceptionKeysFound == exceptionKeyCount then
                    break
                end
            end
        end
    end)

    if not success then
        local failedMessage = ("Failed to fetch key ( %s )"):format(errorMessage)

        for keyName in exceptionKeys do
            networkKeys[keyName] = failedMessage
        end
    end
end

--// Fetch keys from functions

for keyName, keyFunction in keyFunctions do
    local success, errorMessage = pcall(function()
        networkKeys[keyName] = fetchKey(keyFunction()) or "Failed to fetch key"
    end)

    if not success or networkKeys[keyName] == "Failed to fetch key" then
        if backupKeys[keyName] then
            success, errorMessage = pcall(function()
                networkKeys[keyName] = fetchKey(keyFunction(true)) or "Failed to fetch key"
            end)
        end

        if not success then
            networkKeys[keyName] = ("Failed to fetch key ( %s )"):format(errorMessage)
        end
    end
end

--// Return variables

local environment = getgenv()

environment.networkKeys, environment.network = networkKeys, network

return networkKeys, network
